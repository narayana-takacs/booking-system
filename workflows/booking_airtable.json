{
  "name": "Squarespace Booking Automation",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "booking-request",
        "responseMode": "lastNode",
        "options": {
          "responseContentType": "application/json"
        }
      },
      "name": "Receive Booking Request",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -900,
        0
      ],
      "webhookId": "bookingRequest"
    },
    {
      "parameters": {
        "keepOnlySet": false,
        "values": {
          "string": [
            {
              "name": "config.airtableUseStub",
              "value": "={{$env[\"AIRTABLE_USE_STUB\"]}}"
            },
            {
              "name": "config.airtablePat",
              "value": "={{$env[\"AIRTABLE_PAT\"]}}"
            },
            {
              "name": "config.airtableBaseId",
              "value": "={{$env[\"AIRTABLE_BASE_ID\"]}}"
            },
            {
              "name": "config.airtableAvailabilityTable",
              "value": "={{$env[\"AIRTABLE_TABLE_AVAILABILITY\"]}}"
            },
            {
              "name": "config.airtableBookingsTable",
              "value": "={{$env[\"AIRTABLE_TABLE_BOOKINGS\"]}}"
            },
            {
              "name": "config.airtableClientsTable",
              "value": "={{$env[\"AIRTABLE_TABLE_CLIENTS\"]}}"
            },
            {
              "name": "config.providerAlertEmail",
              "value": "={{$env[\"PROVIDER_ALERT_EMAIL\"]}}"
            }
          ]
        }
      },
      "name": "Load Configuration",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [
        -740,
        0
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javascript",
        "jsCode": "const body = (items[0].json.body ?? items[0].json) || {};\nconst config = items[0].json.config || {};\nconst requiredFields = ['name', 'email', 'bookingReason', 'requestedStart', 'requestedEnd'];\nconst missing = requiredFields.filter((field) => !body[field] || String(body[field]).trim() === '');\nif (missing.length) {\n  return [{ json: { status: 'error', message: `Missing fields: ${missing.join(', ')}` }, pairedItem: { item: 0 } }];\n}\nconst toISO = (value) => {\n  const date = new Date(value);\n  if (Number.isNaN(date.getTime())) {\n    throw new Error(`Invalid date value: ${value}`);\n  }\n  return date;\n};\nconst slotStart = toISO(body.requestedStart);\nconst slotEnd = toISO(body.requestedEnd);\nif (slotEnd <= slotStart) {\n  return [{ json: { status: 'error', message: 'requestedEnd must be after requestedStart' }, pairedItem: { item: 0 } }];\n}\nconst envValue = (config.airtableUseStub ?? process.env.AIRTABLE_USE_STUB ?? '').toString().trim().toLowerCase();\nconst useStub = envValue === 'true';\nconst airtableToken = config.airtablePat || process.env.AIRTABLE_PAT;\nconst baseId = config.airtableBaseId || process.env.AIRTABLE_BASE_ID;\nconst availabilityTable = config.airtableAvailabilityTable || process.env.AIRTABLE_TABLE_AVAILABILITY;\nconst bookingsTable = config.airtableBookingsTable || process.env.AIRTABLE_TABLE_BOOKINGS;\nconst clientsTable = config.airtableClientsTable || process.env.AIRTABLE_TABLE_CLIENTS;\nif (!useStub && (!airtableToken || !baseId || !availabilityTable || !bookingsTable || !clientsTable)) {\n  const debug = {\n    useStub,\n    envValue,\n    airtableTokenPresent: Boolean(airtableToken),\n    baseIdPresent: Boolean(baseId),\n    availabilityTable,\n    bookingsTable,\n    clientsTable,\n  };\n  throw new Error('Incomplete Airtable configuration in environment variables. Set AIRTABLE_USE_STUB=true for local testing. Debug: ' + JSON.stringify(debug));\n}\nconst safeQuote = (value) => String(value).replace(/'/g, \"''\");\nlet clientRecord;\nlet clientStatusRaw = 'unknown';\nlet availabilityRecords = [];\nlet bookingsRecords = [];\nlet createBookingRecord;\nif (useStub) {\n  const stubStatus = (body.stubClientStatus || 'Active').toLowerCase();\n  clientStatusRaw = stubStatus;\n  clientRecord = {\n    id: 'stub-client',\n    fields: {\n      Status: stubStatus.charAt(0).toUpperCase() + stubStatus.slice(1),\n    },\n  };\n  availabilityRecords = [\n    {\n      fields: {\n        Start: body.stubAvailabilityStart || slotStart.toISOString(),\n        End: body.stubAvailabilityEnd || slotEnd.toISOString(),\n      },\n    },\n  ];\n  bookingsRecords = (body.stubExistingBookings || []).map((booking, index) => ({\n    id: `stub-booking-${index}`,\n    fields: {\n      Status: booking.status || 'Accepted',\n      Start: booking.start,\n      End: booking.end,\n    },\n  }));\n  createBookingRecord = async (fields) => ({ id: `stub-booking-${Date.now()}`, fields });\n} else {\n  const headers = {\n    Authorization: `Bearer ${airtableToken}`,\n  };\n  const fetchAll = async (table, params = {}) => {\n    let offset;\n    const records = [];\n    do {\n      const queryParams = { pageSize: '100', ...params };\n      if (offset) queryParams.offset = offset;\n      const queryString = Object.entries(queryParams)\n        .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)\n        .join('&');\n      const response = await this.helpers.httpRequest({\n        method: 'GET',\n        url: `https://api.airtable.com/v0/${baseId}/${encodeURIComponent(table)}?${queryString}`,\n        headers,\n        json: true,\n      });\n      records.push(...(response.records || []));\n      offset = response.offset;\n    } while (offset);\n    return records;\n  };\n  const createRecord = async (table, fields) => {\n    return this.helpers.httpRequest({\n      method: 'POST',\n      url: `https://api.airtable.com/v0/${baseId}/${encodeURIComponent(table)}`,\n      headers,\n      body: { fields },\n      json: true,\n    });\n  };\n  const emailLower = body.email.trim().toLowerCase();\n  const clientRecords = await fetchAll(clientsTable, {\n    filterByFormula: `LOWER({Email})='${safeQuote(emailLower)}'`,\n  });\n  clientRecord = clientRecords[0];\n  if (!clientRecord) {\n    const newClientFields = {\n      Name: body.name,\n      Email: body.email,\n      Status: 'Unknown',\n      'Latest Reason': body.bookingReason,\n    };\n    const created = await createRecord(clientsTable, newClientFields);\n    clientRecord = { id: created.id, fields: newClientFields };\n  }\n  clientStatusRaw = (clientRecord.fields?.Status || 'Unknown').toLowerCase();\n  availabilityRecords = await fetchAll(availabilityTable);\n  bookingsRecords = await fetchAll(bookingsTable, {\n    filterByFormula: \"NOT({Status}='Cancelled')\",\n  });\n  createBookingRecord = async (fields) => createRecord(bookingsTable, fields);\n}\nclientStatusRaw = clientStatusRaw || 'unknown';\nconst findMatchingAvailability = availabilityRecords.find((record) => {\n  const startRaw = record.fields?.Start;\n  const endRaw = record.fields?.End;\n  if (!startRaw || !endRaw) return false;\n  const availStart = new Date(startRaw);\n  const availEnd = new Date(endRaw);\n  return availStart <= slotStart && availEnd >= slotEnd;\n});\nconst acceptedBookings = bookingsRecords.filter((record) => (record.fields?.Status || '').toLowerCase() === 'accepted');\nconst overlapsExisting = acceptedBookings.some((record) => {\n  const startRaw = record.fields?.Start;\n  const endRaw = record.fields?.End;\n  if (!startRaw || !endRaw) return false;\n  const existingStart = new Date(startRaw);\n  const existingEnd = new Date(endRaw);\n  return slotStart < existingEnd && slotEnd > existingStart;\n});\nlet status = 'pending';\nlet message = 'Request submitted and awaiting provider review.';\nconst availabilityMatched = Boolean(findMatchingAvailability);\nlet bookingResult = null;\nconst fieldsBase = {\n  'Client Name': body.name,\n  Email: body.email,\n  Start: slotStart.toISOString(),\n  End: slotEnd.toISOString(),\n  'Booking Reason': body.bookingReason,\n  'Client Status': clientStatusRaw.charAt(0).toUpperCase() + clientStatusRaw.slice(1),\n  Source: 'Squarespace',\n};\nif (!availabilityMatched) {\n  status = 'unavailable';\n  message = 'Requested slot does not fall within available working hours.';\n} else if (overlapsExisting) {\n  status = 'unavailable';\n  message = 'Requested slot is no longer available. Please select another time.';\n} else if (clientStatusRaw === 'active') {\n  status = 'accepted';\n  message = 'Booking confirmed.';\n  bookingResult = await createBookingRecord({\n    ...fieldsBase,\n    Status: 'Accepted',\n    'Decision Timestamp': new Date().toISOString(),\n  });\n} else {\n  status = 'pending';\n  message = 'Request submitted and awaiting provider review.';\n  bookingResult = await createBookingRecord({\n    ...fieldsBase,\n    Status: 'Pending Review',\n  });\n}\nconst response = {\n  status,\n  message,\n  clientStatus: clientStatusRaw,\n  slot: { start: slotStart.toISOString(), end: slotEnd.toISOString() },\n  availabilityMatched,\n  overlapsExisting,\n  airtable: {\n    clientRecordId: clientRecord?.id || null,\n    bookingRecordId: bookingResult?.id || null,\n  },\n  client: { name: body.name, email: body.email },\n  bookingReason: body.bookingReason,\n};\nif (status === 'accepted') {\n  const formatICSDate = (date) => date.toISOString().replace(/[-:]/g, '').replace(/\\.\\d{3}Z$/, 'Z');\n  const summary = `Session with ${body.name}`;\n  const uid = `${(bookingResult?.id || Date.now())}@booking-assistant`;\n  const description = `Reason: ${body.bookingReason}`.replace(/\\n/g, '\\\\n');\n  const ics = `BEGIN:VCALENDAR\\nVERSION:2.0\\nPRODID:-//Booking Assistant//EN\\nBEGIN:VEVENT\\nUID:${uid}\\nDTSTAMP:${formatICSDate(new Date())}\\nDTSTART:${formatICSDate(slotStart)}\\nDTEND:${formatICSDate(slotEnd)}\\nSUMMARY:${summary}\\nDESCRIPTION:${description}\\nEND:VEVENT\\nEND:VCALENDAR`;\n  response.clientEmail = {\n    to: body.email,\n    subject: 'Booking confirmed',\n    text: `Hi ${body.name},\\n\\nYour session is confirmed from ${slotStart.toISOString()} to ${slotEnd.toISOString()}.\\n\\nReason: ${body.bookingReason}\\n\\nYou can add the attached calendar invite to your preferred calendar.\\n\\nRegards,\\nProvider`,\n  };\n  response.providerEmail = {\n    to: config.providerAlertEmail || process.env.PROVIDER_ALERT_EMAIL || 'provider@example.com',\n    subject: 'New confirmed booking',\n    text: `Client: ${body.name}\\nEmail: ${body.email}\\nStart: ${slotStart.toISOString()}\\nEnd: ${slotEnd.toISOString()}\\nReason: ${body.bookingReason}\\nStatus: Accepted`,\n  };\n  return [{\n    json: response,\n    binary: {\n      ics: {\n        data: Buffer.from(ics, 'utf8').toString('base64'),\n        mimeType: 'text/calendar; charset=utf-8',\n        fileName: 'booking.ics',\n      },\n    },\n  }];\n}\nif (status === 'pending') {\n  response.providerEmail = {\n    to: config.providerAlertEmail || process.env.PROVIDER_ALERT_EMAIL || 'provider@example.com',\n    subject: 'Booking request pending review',\n    text: `Client: ${body.name}\\nEmail: ${body.email}\\nStart: ${slotStart.toISOString()}\\nEnd: ${slotEnd.toISOString()}\\nReason: ${body.bookingReason}\\nStatus: Pending Review`,\n  };\n}\nreturn [{ json: response }];\n"
      },
      "name": "Process Booking",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -520,
        0
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{$json}}",
        "options": {
          "responseContentType": "application/json"
        }
      },
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        -320,
        0
      ]
    }
  ],
  "connections": {
    "Receive Booking Request": {
      "main": [
        [
          {
            "node": "Load Configuration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Configuration": {
      "main": [
        [
          {
            "node": "Process Booking",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Booking": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "timezone": "Etc/UTC"
  },
  "pinData": {},
  "active": false
}